================================================================================
PURCHASE TRANSACTION APPLICATION - COMPLETE JAVA SOURCE CODE
================================================================================

This file contains all Java source code needed for the project. Copy each file
to its corresponding location in the project.

================================================================================
FILE 1: src/main/java/com/purchase/transaction/repository/FileBasedTransactionRepository.java
================================================================================

package com.purchase.transaction.repository;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.purchase.transaction.model.PurchaseTransaction;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

@Slf4j
@Repository
public class FileBasedTransactionRepository implements ITransactionRepository {
    
    private static final String TRANSACTIONS_FILENAME = "transactions.json";
    private final String repositoryPath;
    private final ObjectMapper objectMapper;
    private final Map<String, PurchaseTransaction> transactionCache;
    
    public FileBasedTransactionRepository(ObjectMapper objectMapper,
                                          @Value("${app.repository.path:./data}") String repositoryPath) {
        this.objectMapper = objectMapper;
        this.repositoryPath = repositoryPath;
        this.transactionCache = new HashMap<>();
        initializeRepository();
        loadTransactionsFromFile();
    }
    
    private void initializeRepository() {
        try {
            Path path = Paths.get(repositoryPath);
            if (!Files.exists(path)) {
                Files.createDirectories(path);
                log.info("Created repository directory: {}", repositoryPath);
            }
        } catch (IOException e) {
            log.error("Failed to initialize repository directory", e);
            throw new RuntimeException("Failed to initialize repository", e);
        }
    }
    
    private void loadTransactionsFromFile() {
        try {
            File file = getRepositoryFile();
            transactionCache.clear();
            
            if (file.exists()) {
                PurchaseTransaction[] transactions = objectMapper.readValue(file, PurchaseTransaction[].class);
                for (PurchaseTransaction transaction : transactions) {
                    transactionCache.put(transaction.getTransactionId(), transaction);
                }
                log.info("Loaded {} transactions from file", transactions.length);
            } else {
                log.info("Repository file does not exist. Starting with empty repository.");
                saveTransactionsToFile();
            }
        } catch (IOException e) {
            log.error("Failed to load transactions from file", e);
            throw new RuntimeException("Failed to load transactions", e);
        }
    }
    
    private synchronized void saveTransactionsToFile() {
        try {
            File file = getRepositoryFile();
            List<PurchaseTransaction> transactions = new ArrayList<>(transactionCache.values());
            objectMapper.writerWithDefaultPrettyPrinter().writeValue(file, transactions);
            log.debug("Persisted {} transactions to file", transactions.size());
        } catch (IOException e) {
            log.error("Failed to save transactions to file", e);
            throw new RuntimeException("Failed to save transactions", e);
        }
    }
    
    private File getRepositoryFile() {
        return Paths.get(repositoryPath, TRANSACTIONS_FILENAME).toFile();
    }
    
    @Override
    public PurchaseTransaction save(PurchaseTransaction transaction) {
        if (transaction == null) throw new IllegalArgumentException("Transaction cannot be null");
        transactionCache.put(transaction.getTransactionId(), transaction);
        saveTransactionsToFile();
        log.info("Saved transaction with ID: {}", transaction.getTransactionId());
        return transaction;
    }
    
    @Override
    public Optional<PurchaseTransaction> findById(String transactionId) {
        if (transactionId == null || transactionId.trim().isEmpty()) return Optional.empty();
        return Optional.ofNullable(transactionCache.get(transactionId));
    }
    
    @Override
    public List<PurchaseTransaction> findAll() {
        return new ArrayList<>(transactionCache.values());
    }
    
    @Override
    public boolean deleteById(String transactionId) {
        if (transactionId == null || transactionId.trim().isEmpty()) return false;
        boolean existed = transactionCache.containsKey(transactionId);
        if (existed) {
            transactionCache.remove(transactionId);
            saveTransactionsToFile();
            log.info("Deleted transaction with ID: {}", transactionId);
        }
        return existed;
    }
    
    @Override
    public boolean existsById(String transactionId) {
        return transactionId != null && !transactionId.trim().isEmpty() && transactionCache.containsKey(transactionId);
    }
    
    @Override
    public long count() {
        return transactionCache.size();
    }
    
    @Override
    public void deleteAll() {
        transactionCache.clear();
        saveTransactionsToFile();
        log.info("Deleted all transactions");
    }
}

================================================================================
FILE 2: src/main/java/com/purchase/transaction/service/TreasuryExchangeRateService.java
================================================================================

package com.purchase.transaction.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.purchase.transaction.exception.ExchangeRateRetrievalException;
import com.purchase.transaction.model.ExchangeRate;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Service
public class TreasuryExchangeRateService implements IExchangeRateService {
    
    private static final String TREASURY_API_URL = "https://api.fiscaldata.treasury.gov/services/api/fiscal_service/v1/accounting/od/rates_of_exchange";
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;
    private final Map<String, ExchangeRate> exchangeRateCache;
    
    @Value("${app.exchange-rate.cache-enabled:true}")
    private boolean cacheEnabled;
    
    public TreasuryExchangeRateService(ObjectMapper objectMapper) {
        this.restTemplate = new RestTemplate();
        this.objectMapper = objectMapper;
        this.exchangeRateCache = new ConcurrentHashMap<>();
    }
    
    @Override
    public List<ExchangeRate> getExchangeRatesForDate(LocalDate date) {
        if (date == null) throw new IllegalArgumentException("Date cannot be null");
        
        try {
            String formattedDate = date.format(DATE_FORMATTER);
            String filter = String.format("exchange_rate_date:eq:\"%s\"", formattedDate);
            String url = String.format("%s?filter=%s&limit=500", TREASURY_API_URL, encodeFilter(filter));
            
            log.debug("Fetching exchange rates from Treasury API for date: {}", formattedDate);
            String response = restTemplate.getForObject(url, String.class);
            return parseExchangeRates(response, date);
        } catch (Exception e) {
            log.error("Failed to retrieve exchange rates for date: {}", date, e);
            throw new ExchangeRateRetrievalException(String.format("Failed to retrieve exchange rates for date: %s", date), e);
        }
    }
    
    @Override
    public Optional<ExchangeRate> getExchangeRateForCurrency(String currencyCode, LocalDate date) {
        if (currencyCode == null || currencyCode.trim().isEmpty()) throw new IllegalArgumentException("Currency code cannot be null or empty");
        if (date == null) throw new IllegalArgumentException("Date cannot be null");
        
        String cacheKey = getCacheKey(currencyCode, date);
        if (cacheEnabled && exchangeRateCache.containsKey(cacheKey)) {
            return Optional.of(exchangeRateCache.get(cacheKey));
        }
        
        try {
            String formattedDate = date.format(DATE_FORMATTER);
            String filter = String.format("exchange_rate_date:eq:\"%s\" and currency_code:eq:\"%s\"", formattedDate, currencyCode.toUpperCase());
            String url = String.format("%s?filter=%s", TREASURY_API_URL, encodeFilter(filter));
            
            log.debug("Fetching exchange rate from Treasury API for currency: {} on date: {}", currencyCode, formattedDate);
            String response = restTemplate.getForObject(url, String.class);
            List<ExchangeRate> rates = parseExchangeRates(response, date);
            
            if (!rates.isEmpty()) {
                ExchangeRate rate = rates.get(0);
                if (cacheEnabled) exchangeRateCache.put(cacheKey, rate);
                return Optional.of(rate);
            }
            
            log.warn("No exchange rate found for currency: {} on date: {}", currencyCode, date);
            return Optional.empty();
        } catch (Exception e) {
            log.error("Failed to retrieve exchange rate for currency: {} on date: {}", currencyCode, date, e);
            throw new ExchangeRateRetrievalException(String.format("Failed to retrieve exchange rate for currency: %s", currencyCode), e);
        }
    }
    
    @Override
    public List<String> getAvailableCurrencies() {
        try {
            LocalDate today = LocalDate.now();
            String formattedDate = today.format(DATE_FORMATTER);
            String filter = String.format("exchange_rate_date:eq:\"%s\"", formattedDate);
            String url = String.format("%s?filter=%s&limit=500", TREASURY_API_URL, encodeFilter(filter));
            
            log.debug("Fetching available currencies from Treasury API");
            String response = restTemplate.getForObject(url, String.class);
            List<ExchangeRate> rates = parseExchangeRates(response, today);
            
            List<String> currencies = new ArrayList<>();
            Set<String> uniqueCurrencies = new LinkedHashSet<>();
            
            for (ExchangeRate rate : rates) {
                uniqueCurrencies.add(rate.getCurrencyCode());
            }
            
            currencies.addAll(uniqueCurrencies);
            Collections.sort(currencies);
            
            log.info("Found {} available currencies", currencies.size());
            return currencies;
        } catch (Exception e) {
            log.error("Failed to retrieve available currencies", e);
            throw new ExchangeRateRetrievalException("Failed to retrieve available currencies", e);
        }
    }
    
    private List<ExchangeRate> parseExchangeRates(String jsonResponse, LocalDate date) throws IOException {
        List<ExchangeRate> rates = new ArrayList<>();
        JsonNode root = objectMapper.readTree(jsonResponse);
        JsonNode dataNode = root.path("data");
        
        if (dataNode.isArray()) {
            for (JsonNode node : dataNode) {
                try {
                    ExchangeRate rate = ExchangeRate.builder()
                        .currencyCode(node.path("currency_code").asText())
                        .currencyName(node.path("currency_name").asText())
                        .exchangeRate(new BigDecimal(node.path("exchange_rate").asText()))
                        .effectiveDate(date)
                        .countryCode(node.path("country_code").asText())
                        .build();
                    rates.add(rate);
                } catch (Exception e) {
                    log.warn("Failed to parse exchange rate record", e);
                }
            }
        }
        
        log.info("Parsed {} exchange rates from API response", rates.size());
        return rates;
    }
    
    private String encodeFilter(String filter) {
        return filter.replace(" ", "%20").replace("\"", "%22").replace(":", "%3A");
    }
    
    private String getCacheKey(String currencyCode, LocalDate date) {
        return currencyCode.toUpperCase() + "_" + date.format(DATE_FORMATTER);
    }
}

================================================================================
FILE 3: src/main/java/com/purchase/transaction/service/PurchaseTransactionService.java
================================================================================

package com.purchase.transaction.service;

import com.purchase.transaction.exception.ExchangeRateRetrievalException;
import com.purchase.transaction.exception.TransactionNotFoundException;
import com.purchase.transaction.exception.TransactionValidationException;
import com.purchase.transaction.model.ConvertedTransaction;
import com.purchase.transaction.model.ExchangeRate;
import com.purchase.transaction.model.PurchaseTransaction;
import com.purchase.transaction.repository.ITransactionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class PurchaseTransactionService implements IPurchaseTransactionService {
    
    private final ITransactionRepository transactionRepository;
    private final IExchangeRateService exchangeRateService;
    
    @Override
    public PurchaseTransaction createTransaction(String description, LocalDate transactionDate, BigDecimal amount) {
        log.info("Creating new transaction: description='{}', date={}, amount={}", description, transactionDate, amount);
        
        if (description == null || description.trim().isEmpty()) 
            throw new TransactionValidationException("Description cannot be null or empty");
        if (description.length() > 50) 
            throw new TransactionValidationException(String.format("Description exceeds 50 characters: %d", description.length()));
        if (transactionDate == null) 
            throw new TransactionValidationException("Transaction date cannot be null");
        if (transactionDate.isAfter(LocalDate.now())) 
            throw new TransactionValidationException("Transaction date cannot be in the future");
        if (amount == null || amount.signum() <= 0) 
            throw new TransactionValidationException("Amount must be a positive number");
        
        BigDecimal roundedAmount = amount.setScale(2, RoundingMode.HALF_UP);
        
        if (roundedAmount.signum() <= 0) 
            throw new TransactionValidationException("Amount must be a positive number");
        
        PurchaseTransaction transaction = PurchaseTransaction.create(description, transactionDate, roundedAmount);
        
        if (!transaction.isValid()) 
            throw new TransactionValidationException("Transaction validation failed");
        
        PurchaseTransaction savedTransaction = transactionRepository.save(transaction);
        log.info("Successfully created transaction with ID: {}", savedTransaction.getTransactionId());
        return savedTransaction;
    }
    
    @Override
    public PurchaseTransaction getTransaction(String transactionId) {
        log.debug("Retrieving transaction with ID: {}", transactionId);
        if (transactionId == null || transactionId.trim().isEmpty()) 
            throw new IllegalArgumentException("Transaction ID cannot be null or empty");
        
        return transactionRepository.findById(transactionId)
            .orElseThrow(() -> {
                log.warn("Transaction not found with ID: {}", transactionId);
                return new TransactionNotFoundException(String.format("Transaction not found with ID: %s", transactionId));
            });
    }
    
    @Override
    public List<PurchaseTransaction> getAllTransactions() {
        log.debug("Retrieving all transactions");
        List<PurchaseTransaction> transactions = transactionRepository.findAll();
        log.info("Retrieved {} transactions", transactions.size());
        return transactions;
    }
    
    @Override
    public void deleteTransaction(String transactionId) {
        log.info("Deleting transaction with ID: {}", transactionId);
        if (transactionId == null || transactionId.trim().isEmpty()) 
            throw new IllegalArgumentException("Transaction ID cannot be null or empty");
        
        boolean deleted = transactionRepository.deleteById(transactionId);
        if (!deleted) {
            log.warn("Transaction not found with ID: {}", transactionId);
            throw new TransactionNotFoundException(String.format("Transaction not found with ID: %s", transactionId));
        }
        log.info("Successfully deleted transaction with ID: {}", transactionId);
    }
    
    @Override
    public ConvertedTransaction convertTransaction(String transactionId, String currencyCode) {
        log.info("Converting transaction {} to currency: {}", transactionId, currencyCode);
        
        if (transactionId == null || transactionId.trim().isEmpty()) 
            throw new IllegalArgumentException("Transaction ID cannot be null or empty");
        if (currencyCode == null || currencyCode.trim().isEmpty()) 
            throw new IllegalArgumentException("Currency code cannot be null or empty");
        
        PurchaseTransaction transaction = getTransaction(transactionId);
        
        ExchangeRate exchangeRate = exchangeRateService
            .getExchangeRateForCurrency(currencyCode.toUpperCase(), transaction.getTransactionDate())
            .orElseThrow(() -> {
                log.error("No exchange rate found for currency: {} on date: {}", currencyCode, transaction.getTransactionDate());
                return new ExchangeRateRetrievalException(
                    String.format("No exchange rate found for currency: %s on date: %s", currencyCode, transaction.getTransactionDate()));
            });
        
        BigDecimal convertedAmount = transaction.getAmount()
            .multiply(exchangeRate.getExchangeRate())
            .setScale(2, RoundingMode.HALF_UP);
        
        ConvertedTransaction converted = ConvertedTransaction.builder()
            .transactionId(transaction.getTransactionId())
            .description(transaction.getDescription())
            .transactionDate(transaction.getTransactionDate())
            .originalAmountUsd(transaction.getAmount())
            .currencyCode(exchangeRate.getCurrencyCode())
            .exchangeRate(exchangeRate.getExchangeRate())
            .convertedAmount(convertedAmount)
            .exchangeRateDate(exchangeRate.getEffectiveDate())
            .build();
        
        log.info("Successfully converted transaction {} to {}: {} -> {}", transactionId, currencyCode, transaction.getAmount(), convertedAmount);
        return converted;
    }
    
    @Override
    public List<String> getAvailableCurrencies() {
        log.debug("Retrieving available currencies");
        return exchangeRateService.getAvailableCurrencies();
    }
}

================================================================================
FILE 4: src/main/java/com/purchase/transaction/config/GlobalExceptionHandler.java
================================================================================

package com.purchase.transaction.config;

import com.purchase.transaction.exception.ExchangeRateRetrievalException;
import com.purchase.transaction.exception.TransactionNotFoundException;
import com.purchase.transaction.exception.TransactionValidationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {
    
    @ExceptionHandler(TransactionValidationException.class)
    public ResponseEntity<Map<String, Object>> handleValidationException(TransactionValidationException ex) {
        log.warn("Validation error: {}", ex.getMessage());
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Validation Error");
        body.put("message", ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(TransactionNotFoundException.class)
    public ResponseEntity<Map<String, Object>> handleNotFoundException(TransactionNotFoundException ex) {
        log.warn("Transaction not found: {}", ex.getMessage());
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Not Found");
        body.put("message", ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }
    
    @ExceptionHandler(ExchangeRateRetrievalException.class)
    public ResponseEntity<Map<String, Object>> handleExchangeRateException(ExchangeRateRetrievalException ex) {
        log.error("Exchange rate retrieval error: {}", ex.getMessage());
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.SERVICE_UNAVAILABLE.value());
        body.put("error", "Service Unavailable");
        body.put("message", ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.SERVICE_UNAVAILABLE);
    }
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Map<String, Object>> handleIllegalArgumentException(IllegalArgumentException ex) {
        log.warn("Invalid argument: {}", ex.getMessage());
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request");
        body.put("message", ex.getMessage());
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleGenericException(Exception ex) {
        log.error("Unexpected error occurred", ex);
        Map<String, Object> body = new HashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        body.put("error", "Internal Server Error");
        body.put("message", "An unexpected error occurred. Please try again later.");
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

================================================================================
FILE 5: src/main/java/com/purchase/transaction/controller/TransactionController.java
================================================================================

package com.purchase.transaction.controller;

import com.purchase.transaction.model.PurchaseTransaction;
import com.purchase.transaction.service.IPurchaseTransactionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/api/v1/transactions")
@RequiredArgsConstructor
public class TransactionController {
    
    private final IPurchaseTransactionService transactionService;
    
    @PostMapping
    public ResponseEntity<PurchaseTransaction> createTransaction(
            @RequestParam String description,
            @RequestParam String transactionDate,
            @RequestParam BigDecimal amount) {
        log.info("Received request to create transaction: description='{}', date={}, amount={}", description, transactionDate, amount);
        LocalDate date = LocalDate.parse(transactionDate);
        PurchaseTransaction transaction = transactionService.createTransaction(description, date, amount);
        return ResponseEntity.status(HttpStatus.CREATED).body(transaction);
    }
    
    @GetMapping("/{transactionId}")
    public ResponseEntity<PurchaseTransaction> getTransaction(@PathVariable String transactionId) {
        log.info("Received request to get transaction: {}", transactionId);
        PurchaseTransaction transaction = transactionService.getTransaction(transactionId);
        return ResponseEntity.ok(transaction);
    }
    
    @GetMapping
    public ResponseEntity<List<PurchaseTransaction>> getAllTransactions() {
        log.info("Received request to get all transactions");
        List<PurchaseTransaction> transactions = transactionService.getAllTransactions();
        return ResponseEntity.ok(transactions);
    }
    
    @DeleteMapping("/{transactionId}")
    public ResponseEntity<Map<String, String>> deleteTransaction(@PathVariable String transactionId) {
        log.info("Received request to delete transaction: {}", transactionId);
        transactionService.deleteTransaction(transactionId);
        Map<String, String> response = new HashMap<>();
        response.put("message", "Transaction deleted successfully");
        response.put("transactionId", transactionId);
        return ResponseEntity.ok(response);
    }
}

================================================================================
FILE 6: src/main/java/com/purchase/transaction/controller/CurrencyConversionController.java
================================================================================

package com.purchase.transaction.controller;

import com.purchase.transaction.model.ConvertedTransaction;
import com.purchase.transaction.service.IPurchaseTransactionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@Slf4j
@RestController
@RequestMapping("/api/v1/conversions")
@RequiredArgsConstructor
public class CurrencyConversionController {
    
    private final IPurchaseTransactionService transactionService;
    
    @GetMapping("/{transactionId}")
    public ResponseEntity<ConvertedTransaction> convertTransaction(
            @PathVariable String transactionId,
            @RequestParam String currency) {
        log.info("Received request to convert transaction {} to currency: {}", transactionId, currency);
        ConvertedTransaction converted = transactionService.convertTransaction(transactionId, currency);
        return ResponseEntity.ok(converted);
    }
    
    @GetMapping("/currencies/available")
    public ResponseEntity<List<String>> getAvailableCurrencies() {
        log.info("Received request to get available currencies");
        List<String> currencies = transactionService.getAvailableCurrencies();
        return ResponseEntity.ok(currencies);
    }
}

================================================================================
END OF JAVA SOURCE CODE
================================================================================

To complete the project:
1. Copy each file to its corresponding location
2. Run: mvn clean install
3. Run: mvn spring-boot:run
4. Application will be available at http://localhost:8080

For test files and additional documentation, see the full README.md file.

